use crate::block::Block;
use crate::transaction::Transaction;
use crate::types::PeerId; // Assuming PeerId will be a type alias for libp2p::PeerId or our own wrapper

use libp2p::{
    futures::StreamExt, // For swarm.select_next_some()
    gossipsub::{self, IdentTopic as Topic, MessageAuthenticity, MessageId, ValidationMode},
    identity,
    mdns,
    multiaddr::Protocol,
    swarm::{NetworkBehaviour, SwarmBuilder, SwarmEvent},
    Multiaddr,
    Swarm,
    tcp::tokio::Transport as TokioTcpTransport, // Explicitly use tokio-based TCP transport
};
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, oneshot};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use thiserror::Error;
use tracing::{debug, error, info, warn};

// Re-export libp2p PeerId for convenience if not using a custom wrapper
pub use libp2p::PeerId as Libp2pPeerId;

const TRANSACTION_TOPIC: &str = "transactions";
const BLOCK_TOPIC: &str = "blocks";

/// Configuration for the NetworkService.
#[derive(Debug, Clone)]
pub struct NetworkConfig {
    pub listen_address: Multiaddr,
    pub bootstrap_peers: Vec<Multiaddr>,
    // Add other network-specific configurations as needed
}

impl Default for NetworkConfig {
    fn default() -> Self {
        let mut listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse().expect("Invalid default listen address");
        // Example of adding a p2p protocol part for full address specification if needed later
        // listen_addr.push(Protocol::P2p(identity::Keypair::generate_ed25519().public().to_peer_id().into()));
        NetworkConfig {
            listen_address: listen_addr,
            bootstrap_peers: Vec::new(),
        }
    }
}

/// Messages that nodes can send to each other over the network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMessage {
    NewTransaction(Transaction),
    NewBlock(Block),
    // Potentially other message types later, e.g., for block requests
}

/// Custom NetworkBehaviour that combines Gossipsub and Mdns.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "RustchainNetworkEvent")] // to_swarm generates events from this behaviour for the Swarm event loop
pub struct RustchainNetworkBehaviour {
    pub gossipsub: gossipsub::Behaviour,
    pub mdns: mdns::tokio::Behaviour, // Use tokio-based mDNS
    // We might add other behaviours later, e.g., Kademlia for DHT, RequestResponse for direct messages.
}

/// Events generated by the RustchainNetworkBehaviour.
/// These are then processed in the Swarm event loop.
pub enum RustchainNetworkEvent {
    Gossipsub(gossipsub::Event),
    Mdns(mdns::Event),
    // Add other behaviour event variants if new behaviours are added
}

// Implement From conversions for each behaviour's event type into RustchainNetworkEvent
impl From<gossipsub::Event> for RustchainNetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        RustchainNetworkEvent::Gossipsub(event)
    }
}

impl From<mdns::Event> for RustchainNetworkEvent {
    fn from(event: mdns::Event) -> Self {
        RustchainNetworkEvent::Mdns(event)
    }
}

/// Errors that can occur within the NetworkService.
#[derive(Debug, Error)]
pub enum NetworkError {
    #[error("libp2p transport error: {0}")]
    TransportError(#[from] libp2p::TransportError<std::io::Error>),
    #[error("Dial error: {0}")]
    DialError(#[from] libp2p::swarm::DialError),
    #[error("Identity key generation error: {0}")]
    IdentityKeyError(String),
    #[error("Failed to build Swarm: {0}")]
    SwarmBuildError(String),
    #[error("Listen on address failed: {0}")]
    ListenError(String),
    #[error("Serialization error for network message: {0}")]
    SerializationError(#[from] bincode::Error),
    #[error("Command channel send error: {0}")]
    CommandSendError(String),
}

// Placeholder for the NetworkService structure
#[derive(Debug)]
pub struct NetworkService {
    // swarm: Swarm<RustchainNetworkBehaviour>,
    // command_sender: mpsc::Sender<NetworkCommand>,
    // local_peer_id: Libp2pPeerId,
    // Further fields will be added, e.g., channels for incoming messages to other modules
}

// Placeholder for NetworkCommand enum (commands sent to the NetworkService event loop)
pub enum NetworkCommand {
    ListenOn(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    Dial(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    BroadcastMessage { 
        topic: Topic, 
        message: NetworkMessage 
    },
    // GetConnectedPeers(oneshot::Sender<Vec<Libp2pPeerId>>),
}

impl NetworkService {
    /// Creates a new NetworkService.
    pub async fn new(
        config: NetworkConfig,
        local_keypair: identity::Keypair,
    ) -> Result<Self, NetworkError> {
        let local_peer_id = Libp2pPeerId::from(local_keypair.public());
        info!("Local Peer ID: {}", local_peer_id);

        // Create a Gossipsub topic
        let transaction_topic = Topic::new(TRANSACTION_TOPIC);
        let block_topic = Topic::new(BLOCK_TOPIC);

        // Create a Swarm to manage peers and events.
        // Set up an encrypted DNS-enabled TCP Transport over the Tokio runtime.
        let transport = TokioTcpTransport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(libp2p::core::upgrade::Version::V1Lazy)
            .authenticate(libp2p::noise::Config::new(&local_keypair)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(std::time::Duration::from_secs(20))
            .boxed();

        // To prevent duplicate messages, we hash the message content and use it as an ID.
        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };

        // Set up Gossipsub configuration
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10)) // Exchnage IHAVE/IWANT messages
            .validation_mode(ValidationMode::Strict) // This sets the kind of message validation. The default is Strict (enforce message signing)
            .message_id_fn(message_id_fn) // Use custom message id function
            .build()
            .map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub config: {}", e)))?;

        // Build the Gossipsub behaviour
        let mut gossipsub = gossipsub::Behaviour::new(
            MessageAuthenticity::Signed(local_keypair.clone()), // Messages are signed by the local keypair.
            gossipsub_config,
        ).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub: {}", e.to_string())))?;
        
        gossipsub.subscribe(&transaction_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to transaction topic: {}", e)))?;
        gossipsub.subscribe(&block_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to block topic: {}", e)))?;

        // Create mDNS behaviour for local peer discovery
        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?;

        let behaviour = RustchainNetworkBehaviour { gossipsub, mdns };

        let _swarm = SwarmBuilder::with_tokio_executor(transport, behaviour, local_peer_id).build();
        
        // TODO: Initialize command channel, store swarm and peer_id
        info!("NetworkService initialized. Local Peer ID: {}", local_peer_id);
        
        // For now, just return a placeholder. Implementation of event loop and command handling will follow.
        Ok(NetworkService { })
    }

    // Placeholder for the event loop and other methods
    // pub async fn run(self) { ... }
    // pub fn broadcast_transaction(&self, transaction: Transaction) { ... }
    // pub fn broadcast_block(&self, block: Block) { ... }
}

// Basic tests (more comprehensive tests will require running multiple instances or mocking)
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;

    fn generate_keypair() -> identity::Keypair {
        identity::Keypair::generate_ed25519()
    }

    #[tokio::test]
    async fn test_network_service_new() {
        let keypair = generate_keypair();
        let config = NetworkConfig::default();
        let service_result = NetworkService::new(config, keypair).await;
        assert!(service_result.is_ok(), "Failed to create NetworkService: {:?}", service_result.err());
    }

    // Test for message serialization/deserialization
    #[test]
    fn test_network_message_serialization() {
        use crate::types::{Address, BlockHeight, Nonce, Signature as TypesSignature, Timestamp};

        let keypair = generate_keypair();
        let sender_address = Address::from(keypair.public().to_peer_id().to_bytes()); // Example address
        let recipient_address = Address([1u8; 32]);

        let transaction = Transaction {
            sender: sender_address,
            recipient: recipient_address,
            amount: 100,
            nonce: Nonce(1),
            signature: TypesSignature(keypair.sign(b"test_tx_data").expect("Signing failed")),
        };
        let network_msg_tx = NetworkMessage::NewTransaction(transaction.clone());

        let serialized_tx = bincode::serialize(&network_msg_tx).expect("Failed to serialize transaction message");
        let deserialized_tx: NetworkMessage = bincode::deserialize(&serialized_tx).expect("Failed to deserialize transaction message");

        match deserialized_tx {
            NetworkMessage::NewTransaction(dtx) => assert_eq!(dtx, transaction),
            _ => panic!("Deserialized to wrong message type"),
        }
        
        let block_header = crate::block::BlockHeader {
            parent_hash: crate::types::Hash([0u8; 32]),
            block_number: BlockHeight(1),
            timestamp: Timestamp(0),
            tx_root: crate::types::Hash([1u8; 32]),
            validator: sender_address,
            signature: TypesSignature(keypair.sign(b"test_block_data").expect("Signing failed")),
        };
        let block = Block {
            header: block_header,
            transactions: vec![transaction.clone()],
        };
        let network_msg_block = NetworkMessage::NewBlock(block.clone());
        let serialized_block = bincode::serialize(&network_msg_block).expect("Failed to serialize block message");
        let deserialized_block: NetworkMessage = bincode::deserialize(&serialized_block).expect("Failed to deserialize block message");

        match deserialized_block {
            NetworkMessage::NewBlock(dblock) => assert_eq!(dblock, block),
            _ => panic!("Deserialized to wrong message type for block"),
        }
    }

    // Add more tests here: e.g., trying to start listening, dialing (might need helper test infrastructure)
}
