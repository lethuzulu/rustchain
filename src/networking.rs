use crate::block::Block;
use crate::transaction::Transaction;

use libp2p::{
    futures::StreamExt, 
    gossipsub::{self, IdentTopic as Topic, MessageAuthenticity, MessageId, ValidationMode},
    identity,
    mdns, // For mdns::tokio::Behaviour
    multiaddr::Protocol,
    swarm::{NetworkBehaviour, SwarmEvent},
    SwarmBuilder,
    Multiaddr,
    Swarm,
    tcp::tokio::Transport as TokioTcpTransport, // Ensure "tcp" feature is enabled in Cargo.toml for libp2p
};
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, oneshot};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use thiserror::Error;
use tracing::{debug, error, info, warn};
use bincode::config; // For bincode::config::standard()

pub use libp2p::PeerId as Libp2pPeerId;

const TRANSACTION_TOPIC: &str = "transactions";
const BLOCK_TOPIC: &str = "blocks";

/// Configuration for the NetworkService.
#[derive(Debug, Clone)]
pub struct NetworkConfig {
    pub listen_address: Multiaddr,
    pub bootstrap_peers: Vec<Multiaddr>,
}

impl Default for NetworkConfig {
    fn default() -> Self {
        let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse().expect("Invalid default listen address");
        NetworkConfig {
            listen_address: listen_addr,
            bootstrap_peers: Vec::new(),
        }
    }
}

/// Messages that nodes can send to each other over the network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMessage {
    NewTransaction(Transaction),
    NewBlock(Block),
}

/// Custom NetworkBehaviour that combines Gossipsub and Mdns.
#[derive(NetworkBehaviour)] // Ensure "macros" feature for libp2p in Cargo.toml
#[behaviour(out_event = "RustchainNetworkEvent")]
pub struct RustchainNetworkBehaviour {
    pub gossipsub: gossipsub::Behaviour,
    pub mdns: mdns::tokio::Behaviour, // Ensure "mdns" feature for libp2p in Cargo.toml
}

/// Events generated by the RustchainNetworkBehaviour.
/// These are then processed in the Swarm event loop.
pub enum RustchainNetworkEvent {
    Gossipsub(gossipsub::Event),
    Mdns(mdns::Event),
}

// Implement From conversions for each behaviour's event type into RustchainNetworkEvent
impl From<gossipsub::Event> for RustchainNetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        RustchainNetworkEvent::Gossipsub(event)
    }
}

impl From<mdns::Event> for RustchainNetworkEvent {
    fn from(event: mdns::Event) -> Self {
        RustchainNetworkEvent::Mdns(event)
    }
}

/// Errors that can occur within the NetworkService.
#[derive(Debug, Error)]
pub enum NetworkError {
    #[error("libp2p transport error: {0}")]
    TransportError(#[from] libp2p::TransportError<std::io::Error>),
    #[error("Dial error: {0}")]
    DialError(#[from] libp2p::swarm::DialError),
    #[error("Identity key generation error: {0}")]
    IdentityKeyError(String),
    #[error("Failed to build Swarm: {0}")]
    SwarmBuildError(String),
    #[error("Listen on address failed: {0}")]
    ListenError(String),
    #[error("Serialization error for network message: {0}")]
    SerializationError(#[from] bincode::Error),
    #[error("Command channel send error: {0}")]
    CommandSendError(String),
}

/// The NetworkService handles all peer-to-peer communication for the node.
#[derive(Debug)]
pub struct NetworkService {
    swarm: Swarm<RustchainNetworkBehaviour>,
    local_peer_id: Libp2pPeerId,
    command_receiver: mpsc::Receiver<NetworkCommand>,
    command_sender: mpsc::Sender<NetworkCommand>,
    incoming_message_sender: mpsc::Sender<NetworkMessage>,
    transaction_topic: Topic,
    block_topic: Topic,
    config: NetworkConfig,
}

// Placeholder for NetworkCommand enum (commands sent to the NetworkService event loop)
pub enum NetworkCommand {
    ListenOn(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    Dial(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    BroadcastMessage { 
        topic: Topic, 
        message: NetworkMessage 
    },
}

impl NetworkService {
    /// Creates a new NetworkService and returns it along with a sender channel for commands.
    pub async fn new(
        config_arg: NetworkConfig,
        local_keypair: identity::Keypair,
        incoming_message_sender: mpsc::Sender<NetworkMessage>,
    ) -> Result<(Self, mpsc::Sender<NetworkCommand>), NetworkError> {
        let local_peer_id = Libp2pPeerId::from(local_keypair.public());
        info!("Local Peer ID: {}", local_peer_id);

        let transaction_topic = Topic::new(TRANSACTION_TOPIC);
        let block_topic = Topic::new(BLOCK_TOPIC);

        let transport = TokioTcpTransport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(libp2p::core::upgrade::Version::V1Lazy)
            .authenticate(libp2p::noise::Config::new(&local_keypair)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(std::time::Duration::from_secs(20))
            .boxed();

        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };

        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .build()
            .map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub config: {}", e)))?;

        let mut gossipsub = gossipsub::Behaviour::new(
            MessageAuthenticity::Signed(local_keypair.clone()),
            gossipsub_config,
        ).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub: {}", e.to_string())))?;
        
        gossipsub.subscribe(&transaction_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to transaction topic: {}", e)))?;
        gossipsub.subscribe(&block_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to block topic: {}", e)))?;

        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?;
        let behaviour = RustchainNetworkBehaviour { gossipsub, mdns };

        let swarm = SwarmBuilder::with_tokio_executor(transport, behaviour, local_peer_id).build();
        
        let (command_sender, command_receiver) = mpsc::channel(100);

        info!("NetworkService initialized. Listening on: {:?}", config_arg.listen_address);
        
        let service = Self {
            swarm,
            local_peer_id,
            command_receiver,
            command_sender: command_sender.clone(),
            incoming_message_sender,
            transaction_topic,
            block_topic,
            config: config_arg,
        };

        Ok((service, command_sender))
    }

    /// Returns a clone of the command sender channel to allow other modules to send commands to the NetworkService.
    pub fn command_sender(&self) -> mpsc::Sender<NetworkCommand> {
        self.command_sender.clone()
    }

    /// Broadcasts a transaction to the network via gossipsub.
    pub async fn broadcast_transaction(&self, transaction: Transaction) {
        let network_message = NetworkMessage::NewTransaction(transaction);
        let command = NetworkCommand::BroadcastMessage {
            topic: self.transaction_topic.clone(),
            message: network_message,
        };
        if let Err(e) = self.command_sender.send(command).await {
            error!("Failed to send broadcast transaction command to network service: {}", e);
        }
    }

    /// Broadcasts a block to the network via gossipsub.
    pub async fn broadcast_block(&self, block: Block) {
        let network_message = NetworkMessage::NewBlock(block);
        let command = NetworkCommand::BroadcastMessage {
            topic: self.block_topic.clone(),
            message: network_message,
        };
        if let Err(e) = self.command_sender.send(command).await {
            error!("Failed to send broadcast block command to network service: {}", e);
        }
    }

    /// Runs the NetworkService event loop.
    pub async fn run(mut self) -> Result<(), NetworkError> {
        // Start listening on the configured address.
        self.swarm.listen_on(self.config.listen_address.clone())
            .map_err(|e| NetworkError::ListenError(format!("Listen on address failed: {:?}", e)))?;

        // Dial bootstrap peers if any are configured.
        for addr in &self.config.bootstrap_peers {
            match self.swarm.dial(addr.clone()) {
                Ok(_) => info!("Dialing bootstrap peer: {}", addr),
                Err(e) => warn!("Failed to dial bootstrap peer {}: {:?}", addr, e),
            }
        }

        loop {
            tokio::select! {
                // Event from the Swarm
                event = self.swarm.select_next_some() => {
                    match event {
                        SwarmEvent::NewListenAddr { address, .. } => {
                            info!("Node listening on: {}", address);
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Gossipsub(gossipsub::Event::Message {
                            propagation_source, // peer_id of the peer that sent us this message
                            message_id,         // id of the message
                            message,            // the actual message
                        })) => {
                            let msg_topic = message.topic.to_string();
                            debug!("Received gossip message with id: {} from peer: {} on topic: {}", 
                                   message_id, propagation_source, msg_topic);
                            match bincode::decode_from_slice(&message.data, config::standard()) {
                                Ok((network_message, _)) => {
                                    if let Err(e) = self.incoming_message_sender.send(network_message).await {
                                        error!("Failed to send decoded message to handler: {}", e);
                                    }
                                }
                                Err(e) => {
                                    warn!("Failed to deserialize gossip message: {}. Data: {:?}", e, message.data);
                                }
                            }
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Mdns(mdns::Event::Discovered { list })) => {
                            for (peer_id, multiaddr) in list {
                                info!("mDNS discovered a new peer: {} at {}", peer_id, multiaddr);
                                self.swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
                                // Optionally, try to dial the discovered peer if not already connected
                                // self.swarm.dial(multiaddr).unwrap_or_else(|e| warn!("Failed to dial mDNS peer {}: {:?}", peer_id, e));
                            }
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Mdns(mdns::Event::Expired { list })) => {
                            for (peer_id, multiaddr) in list {
                                debug!("mDNS discover peer has expired: {} at {}", peer_id, multiaddr);
                                // self.swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
                            }
                        }
                        SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                            info!("Connection established with peer: {} at {:?}", peer_id, endpoint.get_remote_address());
                        }
                        SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                            info!("Connection closed with peer: {}. Reason: {:?}", peer_id, cause);
                        }
                        SwarmEvent::DialFailure { peer_id, error, .. } => {
                            warn!("Failed to dial peer {:?}: {}", peer_id, error);
                        }
                        _ => { 
                            // debug!("Unhandled Swarm event: {:?}", event);
                        }
                    }
                }
                // Command from other parts of the application
                Some(command) = self.command_receiver.recv() => {
                    match command {
                        NetworkCommand::ListenOn(addr, responder) => {
                            match self.swarm.listen_on(addr.clone()) {
                                Ok(_) => {
                                    info!("Now also listening on {}", addr);
                                    let _ = responder.send(Ok(())); // Best effort send
                                }
                                Err(e) => {
                                    error!("Failed to listen on {}: {:?}", addr, e);
                                    let _ = responder.send(Err(NetworkError::ListenError(e.to_string())));
                                }
                            }
                        }
                        NetworkCommand::Dial(addr, responder) => {
                            match self.swarm.dial(addr.clone()) {
                                Ok(_) => {
                                    info!("Attempting to dial {}", addr);
                                    let _ = responder.send(Ok(())); // Dialing is async, result comes as SwarmEvent
                                }
                                Err(e) => {
                                    error!("Failed to dial {}: {:?}", addr, e);
                                    let _ = responder.send(Err(NetworkError::DialError(e)));
                                }
                            }
                        }
                        NetworkCommand::BroadcastMessage { topic, message } => {
                            let bincode_cfg = config::standard();
                            match bincode::encode_to_vec(&message, bincode_cfg) {
                                Ok(encoded_message) => {
                                    if let Err(e) = self.swarm.behaviour_mut().gossipsub.publish(topic.clone(), encoded_message) {
                                        error!("Failed to publish message to topic {}: {}", topic, e);
                                    } else {
                                        debug!("Published message to topic: {}", topic);
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to serialize message for broadcast: {}", e);
                                }
                            }
                        }
                    }
                }
                // else => { // Both Swarm and command channel are closed.
                //     info!("NetworkService event loop ended.");
                //     break;
                // }
            }
        }
        // Ok(()) // Loop is infinite, so this is not reached unless loop breaks
    }
}

// Basic tests (more comprehensive tests will require running multiple instances or mocking)
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;
    use crate::types::{Address, BlockHeight, Nonce, Signature as TypesSignature, Timestamp};

    fn generate_keypair() -> identity::Keypair {
        identity::Keypair::generate_ed25519()
    }

    #[tokio::test]
    async fn test_network_service_new() {
        let keypair = generate_keypair();
        let config_arg = NetworkConfig::default();
        let (incoming_tx_sender, _incoming_tx_receiver) = mpsc::channel(10);

        let service_result = NetworkService::new(config_arg, keypair, incoming_tx_sender).await;
        assert!(service_result.is_ok(), "Failed to create NetworkService: {:?}", service_result.err());
        if let Ok((_service, _command_sender)) = service_result {
            // Basic check that objects are created
        } else {
            panic!("NetworkService::new failed");
        }
    }

    #[test]
    fn test_network_message_serialization() {
        let keypair = generate_keypair();
        let sender_address = Address::from(keypair.public().to_peer_id().to_bytes());
        let recipient_address = Address([1u8; 32]);

        let transaction = Transaction {
            sender: sender_address,
            recipient: recipient_address,
            amount: 100,
            nonce: Nonce(1),
            signature: TypesSignature(keypair.sign(b"test_tx_data").expect("Signing failed")),
        };
        let network_msg_tx = NetworkMessage::NewTransaction(transaction.clone());

        let bincode_cfg = config::standard();
        let serialized_tx = bincode::encode_to_vec(&network_msg_tx, bincode_cfg).expect("Failed to serialize transaction message");
        let deserialized_tx: NetworkMessage = bincode::decode_from_slice(&serialized_tx, bincode_cfg).expect("Failed to deserialize transaction message");

        match deserialized_tx {
            NetworkMessage::NewTransaction(dtx) => assert_eq!(dtx, transaction),
            _ => panic!("Deserialized to wrong message type"),
        }
        
        let block_header = crate::block::BlockHeader {
            parent_hash: crate::types::Hash([0u8; 32]),
            block_number: BlockHeight(1),
            timestamp: Timestamp(0),
            tx_root: crate::types::Hash([1u8; 32]),
            validator: sender_address,
            signature: TypesSignature(keypair.sign(b"test_block_data").expect("Signing failed")),
        };
        let block = Block {
            header: block_header,
            transactions: vec![transaction.clone()],
        };
        let network_msg_block = NetworkMessage::NewBlock(block.clone());
        let serialized_block = bincode::encode_to_vec(&network_msg_block, bincode_cfg).expect("Failed to serialize block message");
        let deserialized_block: NetworkMessage = bincode::decode_from_slice(&serialized_block, bincode_cfg).expect("Failed to deserialize block message");

        match deserialized_block {
            NetworkMessage::NewBlock(dblock) => assert_eq!(dblock, block),
            _ => panic!("Deserialized to wrong message type for block"),
        }
    }

}
