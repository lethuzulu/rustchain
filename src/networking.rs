use crate::block::Block;
use crate::transaction::Transaction;
use crate::types::Hash;

use libp2p::core::{Transport, multiaddr::Protocol}; // Corrected import for libp2p_core types
use libp2p::{
    futures::StreamExt, 
    gossipsub::{self, IdentTopic, MessageAuthenticity, ValidationMode},
    identity,
    mdns, // For mdns::tokio::Behaviour
    swarm::{NetworkBehaviour, SwarmEvent, Config as SwarmNetworkConfig}, // Added Config as SwarmNetworkConfig
    Multiaddr,
    Swarm,
    tcp::tokio::Transport as TokioTcpTransport, // Ensure "tcp" feature is enabled in Cargo.toml for libp2p
};
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, oneshot};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash as StdHash, Hasher};
use std::time::Duration;
use thiserror::Error;
use tracing::{debug, error, info, warn};
use bincode::{Encode, Decode};

pub use libp2p::PeerId as Libp2pPeerId;
pub use libp2p::gossipsub::IdentTopic as Topic;

const TRANSACTION_TOPIC: &str = "transactions";
const BLOCK_TOPIC: &str = "blocks";
const SYNC_PROTOCOL: &str = "/rustchain/sync/1.0.0";

/// Configuration for the NetworkService.
#[derive(Debug, Clone)]
pub struct NetworkConfig {
    pub listen_address: Multiaddr,
    pub bootstrap_peers: Vec<Multiaddr>,
}

impl Default for NetworkConfig {
    fn default() -> Self {
        let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse().expect("Invalid default listen address");
        NetworkConfig {
            listen_address: listen_addr,
            bootstrap_peers: Vec::new(),
        }
    }
}

/// Messages that nodes can send to each other over the network.
#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]
pub enum NetworkMessage {
    NewTransaction(Transaction),
    NewBlock(Block),
    SyncRequest { 
        from_height: u64, 
        to_hash: Option<Hash> 
    },
    SyncResponseBlocks { 
        blocks: Vec<Block> 
    },
    SyncResponseNoBlocks,
}

/// Sync request/response types for libp2p request-response protocol
#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]
pub struct SyncRequest {
    pub from_height: u64,
    pub to_hash: Option<Hash>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]
pub enum SyncResponse {
    Blocks(Vec<Block>),
    NoBlocks,
}

/// Custom NetworkBehaviour that combines Gossipsub and Mdns.
#[derive(NetworkBehaviour)] // Ensure "macros" feature for libp2p in Cargo.toml
#[behaviour(out_event = "RustchainNetworkEvent")]
pub struct RustchainNetworkBehaviour {
    pub gossipsub: gossipsub::Behaviour,
    pub mdns: mdns::tokio::Behaviour, // Ensure "mdns" feature for libp2p in Cargo.toml
}

/// Events generated by the RustchainNetworkBehaviour.
/// These are then processed in the Swarm event loop.
#[derive(Debug)] // Added Debug derive
pub enum RustchainNetworkEvent {
    Gossipsub(gossipsub::Event),
    Mdns(mdns::Event),
}

// Implement From conversions for each behaviour's event type into RustchainNetworkEvent
impl From<gossipsub::Event> for RustchainNetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        RustchainNetworkEvent::Gossipsub(event)
    }
}

impl From<mdns::Event> for RustchainNetworkEvent {
    fn from(event: mdns::Event) -> Self {
        RustchainNetworkEvent::Mdns(event)
    }
}

/// Errors that can occur within the NetworkService.
#[derive(Debug, Error)]
pub enum NetworkError {
    #[error("libp2p transport error: {0}")]
    TransportError(#[from] libp2p::TransportError<std::io::Error>),
    #[error("Dial error: {0}")]
    DialError(#[from] libp2p::swarm::DialError),
    #[error("Identity key generation error: {0}")]
    IdentityKeyError(String),
    #[error("Failed to build Swarm: {0}")]
    SwarmBuildError(String),
    #[error("Listen on address failed: {0}")]
    ListenError(String),
    #[error("Serialization error for network message: {0}")]
    SerializationError(String),
    #[error("Command channel send error: {0}")]
    CommandSendError(String),
    #[error("Transport build error: {0}")]
    TransportBuildError(String),
}

/// The NetworkService handles all peer-to-peer communication for the node.
pub struct NetworkService {
    swarm: Swarm<RustchainNetworkBehaviour>,
    local_peer_id: Libp2pPeerId,
    command_receiver: mpsc::Receiver<NetworkCommand>,
    command_sender: mpsc::Sender<NetworkCommand>,
    incoming_message_sender: mpsc::Sender<NetworkMessage>,
    transaction_topic: IdentTopic,
    block_topic: IdentTopic,
    config: NetworkConfig,
}

// Placeholder for NetworkCommand enum (commands sent to the NetworkService event loop)
pub enum NetworkCommand {
    ListenOn(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    Dial(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    BroadcastMessage { 
        topic: IdentTopic, 
        message: NetworkMessage 
    },
    BroadcastBlock(Block),
    BroadcastTransaction(Transaction),
}

impl NetworkService {
    /// Creates a new NetworkService and returns it along with a sender channel for commands.
    pub async fn new(
        config_arg: NetworkConfig,
        local_keypair: identity::Keypair,
        incoming_message_sender: mpsc::Sender<NetworkMessage>,
    ) -> Result<(Self, mpsc::Sender<NetworkCommand>), NetworkError> {
        let local_peer_id = Libp2pPeerId::from(local_keypair.public());
        info!("Local Peer ID: {}", local_peer_id);

        let transaction_topic = IdentTopic::new(TRANSACTION_TOPIC);
        let block_topic = IdentTopic::new(BLOCK_TOPIC);

        let transport = TokioTcpTransport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(libp2p::core::upgrade::Version::V1Lazy)
            .authenticate(libp2p::noise::Config::new(&local_keypair).map_err(|e| NetworkError::TransportBuildError(format!("Noise config error: {:?}",e)))?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(std::time::Duration::from_secs(20))
            .boxed();

        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };

        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .build()
            .map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub config: {}", e)))?;

        let mut gossipsub = gossipsub::Behaviour::new(
            MessageAuthenticity::Signed(local_keypair.clone()),
            gossipsub_config,
        ).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub: {}", e.to_string())))?;
        
        gossipsub.subscribe(&transaction_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to transaction topic: {}", e)))?;
        gossipsub.subscribe(&block_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to block topic: {}", e)))?;

        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)
            .map_err(|e| NetworkError::SwarmBuildError(format!("Failed to create mDNS: {}",e)))?;
        
        let behaviour = RustchainNetworkBehaviour { 
            gossipsub, 
            mdns,
        };

        // Using direct Swarm::new with swarm::Config
        let swarm_network_config = SwarmNetworkConfig::with_tokio_executor();
        let swarm = Swarm::new(transport, behaviour, local_peer_id, swarm_network_config);
        
        let (command_sender, command_receiver) = mpsc::channel(100);

        info!("NetworkService initialized. Listening on: {:?}", config_arg.listen_address);
        
        let service = Self {
            swarm,
            local_peer_id,
            command_receiver,
            command_sender: command_sender.clone(),
            incoming_message_sender,
            transaction_topic,
            block_topic,
            config: config_arg,
        };

        Ok((service, command_sender))
    }

    /// Returns a clone of the command sender channel to allow other modules to send commands to the NetworkService.
    pub fn command_sender(&self) -> mpsc::Sender<NetworkCommand> {
        self.command_sender.clone()
    }

    /// Broadcasts a transaction to the network via gossipsub.
    pub async fn broadcast_transaction(&self, transaction: Transaction) {
        let network_message = NetworkMessage::NewTransaction(transaction);
        let command = NetworkCommand::BroadcastMessage {
            topic: self.transaction_topic.clone(),
            message: network_message,
        };
        if let Err(e) = self.command_sender.send(command).await {
            error!("Failed to send broadcast transaction command to network service: {}", e);
        }
    }

    /// Broadcasts a block to the network via gossipsub.
    pub async fn broadcast_block(&self, block: Block) {
        let network_message = NetworkMessage::NewBlock(block);
        let command = NetworkCommand::BroadcastMessage {
            topic: self.block_topic.clone(),
            message: network_message,
        };
        if let Err(e) = self.command_sender.send(command).await {
            error!("Failed to send broadcast block command to network service: {}", e);
        }
    }

    /// Runs the NetworkService event loop.
    pub async fn run(mut self) -> Result<(), NetworkError> {
        info!(
            "Starting network service. Listening on: {:?}",
            self.config.listen_address
        );
        self.swarm
            .listen_on(self.config.listen_address.clone())?;

        // Dial bootstrap peers if any
        for peer_addr in &self.config.bootstrap_peers {
            info!("Dialing bootstrap peer: {}", peer_addr);
            self.swarm.dial(peer_addr.clone())?;
        }

        loop {
            tokio::select! {
                event = self.swarm.select_next_some() => {
                    match event {
                        SwarmEvent::NewListenAddr { address, .. } => {
                            info!("Node listening on: {}", address.with(Protocol::P2p(self.local_peer_id.into()))); // Use .with()
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Gossipsub(gossipsub::Event::Message {
                            propagation_source: _peer_id, 
                            message_id: _id, 
                            message,
                        })) => {
                            let bincode_cfg = bincode::config::standard();
                            match bincode::decode_from_slice(&message.data, bincode_cfg) { 
                                Ok((network_message, _len)) => { 
                                    if let Err(e) = self.incoming_message_sender.send(network_message).await {
                                        error!("Failed to send incoming message to handler: {}", e);
                                    }
                                }
                                Err(e) => {
                                    warn!("Failed to deserialize gossipsub message: {:?}", e.to_string());
                                }
                            }
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Mdns(mdns::Event::Discovered(list))) => { 
                            for (peer_id, multiaddr) in list {
                                info!("mDNS discovered peer: {} at {}", peer_id, multiaddr);
                                self.swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
                            }
                        }
                        SwarmEvent::Behaviour(RustchainNetworkEvent::Mdns(mdns::Event::Expired(list))) => { 
                            for (peer_id, multiaddr) in list {
                                debug!("mDNS peer expired: {} at {}", peer_id, multiaddr);
                                self.swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
                            }
                        }
                        SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                            info!("Connection established with: {} on {:?}", peer_id, endpoint);
                        }
                        SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                            info!("Connection closed with: {} ({:?})", peer_id, cause);
                        }
                        SwarmEvent::IncomingConnection { local_addr, send_back_addr, .. } => { // Added ..
                            debug!("Incoming connection from {} to {}", send_back_addr, local_addr);
                        }
                        SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, .. } => { // Added ..
                            warn!("Incoming connection error from {} to {}: {}", send_back_addr, local_addr, error);
                        }
                        SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                            warn!("Failed to dial {:?}: {}", peer_id, error);
                        }
                        SwarmEvent::Behaviour(event) => {
                            debug!("Unhandled Behaviour event: {:?}", event); // Requires RustchainNetworkEvent: Debug
                        }
                        _ => {}
                    }
                }
                Some(command) = self.command_receiver.recv() => {
                    match command {
                        NetworkCommand::ListenOn(addr, sender) => {
                            match self.swarm.listen_on(addr) {
                                Ok(_) => {
                                    let _ = sender.send(Ok(()));
                                }
                                Err(e) => {
                                     let _ = sender.send(Err(e.into()));
                                }
                            }
                        }
                        NetworkCommand::Dial(addr, sender) => {
                             match self.swarm.dial(addr) {
                                Ok(_) => { let _ = sender.send(Ok(())); }
                                Err(e) => { let _ = sender.send(Err(e.into())); }
                            }
                        }
                        NetworkCommand::BroadcastMessage { topic, message } => {
                            let bincode_cfg = bincode::config::standard();
                            match bincode::encode_to_vec(&message, bincode_cfg) {
                                Ok(encoded_message) => {
                                    if let Err(e) = self.swarm.behaviour_mut().gossipsub.publish(topic, encoded_message) {
                                        error!("Failed to publish gossipsub message: {:?}", e);
                                    } else {
                                        info!("Broadcasted message on topic");
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to serialize message for broadcast: {:?}", e.to_string());
                                }
                            }
                        }
                        NetworkCommand::BroadcastBlock(block) => {
                            let network_message = NetworkMessage::NewBlock(block);
                            let bincode_cfg = bincode::config::standard();
                            match bincode::encode_to_vec(&network_message, bincode_cfg) {
                                Ok(encoded_message) => {
                                    if let Err(e) = self.swarm.behaviour_mut().gossipsub.publish(self.block_topic.clone(), encoded_message) {
                                        error!("Failed to publish block: {:?}", e);
                                    } else {
                                        info!("Broadcasted block to network");
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to serialize block for broadcast: {:?}", e.to_string());
                                }
                            }
                        }
                        NetworkCommand::BroadcastTransaction(transaction) => {
                            let network_message = NetworkMessage::NewTransaction(transaction);
                            let bincode_cfg = bincode::config::standard();
                            match bincode::encode_to_vec(&network_message, bincode_cfg) {
                                Ok(encoded_message) => {
                                    if let Err(e) = self.swarm.behaviour_mut().gossipsub.publish(self.transaction_topic.clone(), encoded_message) {
                                        error!("Failed to publish transaction: {:?}", e);
                                    } else {
                                        info!("Broadcasted transaction to network");
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to serialize transaction for broadcast: {:?}", e.to_string());
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Basic tests (more comprehensive tests will require running multiple instances or mocking)
#[cfg(test)]
mod tests {
    use super::*;
    use libp2p::multihash::Multihash;
    use tokio::time::sleep;
    use crate::types::{Address, BlockHeight, Nonce, PublicKey, Signature as TypesSignature, Timestamp};

    fn generate_keypair() -> identity::Keypair {
        identity::Keypair::generate_ed25519()
    }

    #[tokio::test]
    async fn test_network_service_new() {
        let keypair = generate_keypair();
        let config_arg = NetworkConfig::default();
        let (incoming_tx_sender, _incoming_tx_receiver) = mpsc::channel(10);

        let service_result = NetworkService::new(config_arg, keypair, incoming_tx_sender).await;
        assert!(service_result.is_ok(), "Failed to create NetworkService: {:?}", service_result.err());
        if let Ok((_service, _command_sender)) = service_result {
            // Basic check that objects are created
        } else {
            panic!("NetworkService::new failed");
        }
    }

    #[test]
    fn test_network_message_serialization() {
        let keypair = generate_keypair();

        let peer_id = keypair.public().to_peer_id();
        let peer_id_bytes = peer_id.to_bytes();

        // Explicitly parse the bytes as a Multihash object
        let multihash_obj: Multihash<256> = Multihash::from_bytes(&peer_id_bytes)
            .expect("Failed to parse PeerId bytes as Multihash. PeerId.to_bytes() should yield a valid multihash.");

        // Now get the digest from the parsed Multihash
        let digest_bytes: &[u8] = multihash_obj.digest();

        // Convert the digest to [u8; 32] for Address
        let address_bytes: [u8; 32] = digest_bytes
            .try_into()
            .expect("Expected Multihash digest to be 32 bytes for Address conversion");
        let sender_address = Address::from(address_bytes);

        let recipient_address = Address([1u8; 32]);

        // Extract Ed25519 public key from libp2p keypair
        let ed25519_public_key = match keypair.public().try_into_ed25519() {
            Ok(pk) => ed25519_dalek::VerifyingKey::from_bytes(&pk.to_bytes())
                .expect("Failed to convert libp2p Ed25519 public key to dalek VerifyingKey"),
            Err(_) => panic!("Test requires Ed25519 keypair"),
        };

        let signature_bytes: Vec<u8> = keypair.sign(b"test_tx_data").expect("Signing failed").to_vec();

        let transaction = Transaction {
            sender: PublicKey(ed25519_public_key),
            recipient: recipient_address,
            amount: 100,
            nonce: Nonce(1),
            signature: crate::types::Signature(signature_bytes),
        };
        let network_msg_tx = NetworkMessage::NewTransaction(transaction.clone());

        let bincode_cfg = bincode::config::standard();
        let serialized_tx = bincode::encode_to_vec(&network_msg_tx, bincode_cfg)
            .expect("Failed to serialize transaction message");
        let (deserialized_tx, _len): (NetworkMessage, usize) =
            bincode::decode_from_slice(&serialized_tx, bincode_cfg)
                .expect("Failed to deserialize transaction message");

        match deserialized_tx {
            NetworkMessage::NewTransaction(dtx) => assert_eq!(dtx, transaction),
            _ => panic!("Deserialized to wrong message type"),
        }

        let block_signature_bytes: Vec<u8> = keypair.sign(b"test_block_data").expect("Signing failed").to_vec();

        let block_header = crate::block::BlockHeader {
            parent_hash: crate::types::Hash([0u8; 32]),
            block_number: BlockHeight(1),
            timestamp: Timestamp(0),
            tx_root: crate::types::Hash([1u8; 32]),
            validator: sender_address,
            signature: crate::types::Signature(block_signature_bytes),
        };
        let block = Block {
            header: block_header,
            transactions: vec![transaction.clone()],
        };
        let network_msg_block = NetworkMessage::NewBlock(block.clone());
        let serialized_block = bincode::encode_to_vec(&network_msg_block, bincode_cfg)
            .expect("Failed to serialize block message");
        let (deserialized_block, _len): (NetworkMessage, usize) =
            bincode::decode_from_slice(&serialized_block, bincode_cfg)
                .expect("Failed to deserialize block message");

        match deserialized_block {
            NetworkMessage::NewBlock(b) => {
                assert_eq!(b.header.block_number, BlockHeight(1));
            }
            _ => panic!("Deserialized to wrong message type for block"),
        }
    }
}
