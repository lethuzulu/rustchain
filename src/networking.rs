use crate::block::Block;
use crate::transaction::Transaction;

use libp2p::{
    futures::StreamExt, 
    gossipsub::{self, IdentTopic as Topic, MessageAuthenticity, MessageId, ValidationMode},
    identity,
    mdns, // For mdns::tokio::Behaviour
    multiaddr::Protocol,
    swarm::{NetworkBehaviour, SwarmEvent},
    SwarmBuilder,
    Multiaddr,
    Swarm,
    tcp::tokio::Transport as TokioTcpTransport, // Ensure "tcp" feature is enabled in Cargo.toml for libp2p
};
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, oneshot};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use thiserror::Error;
use tracing::{debug, error, info, warn};
use bincode::config; // For bincode::config::standard()

pub use libp2p::PeerId as Libp2pPeerId;

const TRANSACTION_TOPIC: &str = "transactions";
const BLOCK_TOPIC: &str = "blocks";

/// Configuration for the NetworkService.
#[derive(Debug, Clone)]
pub struct NetworkConfig {
    pub listen_address: Multiaddr,
    pub bootstrap_peers: Vec<Multiaddr>,
}

impl Default for NetworkConfig {
    fn default() -> Self {
        let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse().expect("Invalid default listen address");
        NetworkConfig {
            listen_address: listen_addr,
            bootstrap_peers: Vec::new(),
        }
    }
}

/// Messages that nodes can send to each other over the network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMessage {
    NewTransaction(Transaction),
    NewBlock(Block),
}

/// Custom NetworkBehaviour that combines Gossipsub and Mdns.
#[derive(NetworkBehaviour)] // Ensure "macros" feature for libp2p in Cargo.toml
#[behaviour(out_event = "RustchainNetworkEvent")]
pub struct RustchainNetworkBehaviour {
    pub gossipsub: gossipsub::Behaviour,
    pub mdns: mdns::tokio::Behaviour, // Ensure "mdns" feature for libp2p in Cargo.toml
}

/// Events generated by the RustchainNetworkBehaviour.
/// These are then processed in the Swarm event loop.
pub enum RustchainNetworkEvent {
    Gossipsub(gossipsub::Event),
    Mdns(mdns::Event),
}

// Implement From conversions for each behaviour's event type into RustchainNetworkEvent
impl From<gossipsub::Event> for RustchainNetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        RustchainNetworkEvent::Gossipsub(event)
    }
}

impl From<mdns::Event> for RustchainNetworkEvent {
    fn from(event: mdns::Event) -> Self {
        RustchainNetworkEvent::Mdns(event)
    }
}

/// Errors that can occur within the NetworkService.
#[derive(Debug, Error)]
pub enum NetworkError {
    #[error("libp2p transport error: {0}")]
    TransportError(#[from] libp2p::TransportError<std::io::Error>),
    #[error("Dial error: {0}")]
    DialError(#[from] libp2p::swarm::DialError),
    #[error("Identity key generation error: {0}")]
    IdentityKeyError(String),
    #[error("Failed to build Swarm: {0}")]
    SwarmBuildError(String),
    #[error("Listen on address failed: {0}")]
    ListenError(String),
    #[error("Serialization error for network message: {0}")]
    SerializationError(#[from] bincode::Error),
    #[error("Command channel send error: {0}")]
    CommandSendError(String),
}

/// The NetworkService handles all peer-to-peer communication for the node.
#[derive(Debug)]
pub struct NetworkService {
    swarm: Swarm<RustchainNetworkBehaviour>,
    local_peer_id: Libp2pPeerId,
    command_receiver: mpsc::Receiver<NetworkCommand>,
    command_sender: mpsc::Sender<NetworkCommand>,
    incoming_message_sender: mpsc::Sender<NetworkMessage>,
    transaction_topic: Topic,
    block_topic: Topic,
}

// Placeholder for NetworkCommand enum (commands sent to the NetworkService event loop)
pub enum NetworkCommand {
    ListenOn(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    Dial(Multiaddr, oneshot::Sender<Result<(), NetworkError>>),
    BroadcastMessage { 
        topic: Topic, 
        message: NetworkMessage 
    },
}

impl NetworkService {
    /// Creates a new NetworkService and returns it along with a sender channel for commands.
    pub async fn new(
        config_arg: NetworkConfig,
        local_keypair: identity::Keypair,
        incoming_message_sender: mpsc::Sender<NetworkMessage>,
    ) -> Result<(Self, mpsc::Sender<NetworkCommand>), NetworkError> {
        let local_peer_id = Libp2pPeerId::from(local_keypair.public());
        info!("Local Peer ID: {}", local_peer_id);

        let transaction_topic = Topic::new(TRANSACTION_TOPIC);
        let block_topic = Topic::new(BLOCK_TOPIC);

        let transport = TokioTcpTransport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(libp2p::core::upgrade::Version::V1Lazy)
            .authenticate(libp2p::noise::Config::new(&local_keypair)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(std::time::Duration::from_secs(20))
            .boxed();

        let message_id_fn = |message: &gossipsub::Message| {
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            gossipsub::MessageId::from(s.finish().to_string())
        };

        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .build()
            .map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub config: {}", e)))?;

        let mut gossipsub = gossipsub::Behaviour::new(
            MessageAuthenticity::Signed(local_keypair.clone()),
            gossipsub_config,
        ).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to build gossipsub: {}", e.to_string())))?;
        
        gossipsub.subscribe(&transaction_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to transaction topic: {}", e)))?;
        gossipsub.subscribe(&block_topic).map_err(|e| NetworkError::SwarmBuildError(format!("Failed to subscribe to block topic: {}", e)))?;

        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?;
        let behaviour = RustchainNetworkBehaviour { gossipsub, mdns };

        let swarm = SwarmBuilder::with_tokio_executor(transport, behaviour, local_peer_id).build();
        
        let (command_sender, command_receiver) = mpsc::channel(100);

        info!("NetworkService initialized. Listening on: {:?}", config_arg.listen_address);
        
        let service = Self {
            swarm,
            local_peer_id,
            command_receiver,
            command_sender: command_sender.clone(),
            incoming_message_sender,
            transaction_topic,
            block_topic,
        };

        Ok((service, command_sender))
    }

    /// Returns a clone of the command sender channel to allow other modules to send commands to the NetworkService.
    pub fn command_sender(&self) -> mpsc::Sender<NetworkCommand> {
        self.command_sender.clone()
    }

    // Placeholder for the event loop and other methods
    // pub async fn run(self) { ... }
    // pub fn broadcast_transaction(&self, transaction: Transaction) { ... }
    // pub fn broadcast_block(&self, block: Block) { ... }
}

// Basic tests (more comprehensive tests will require running multiple instances or mocking)
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;
    use crate::types::{Address, BlockHeight, Nonce, Signature as TypesSignature, Timestamp};

    fn generate_keypair() -> identity::Keypair {
        identity::Keypair::generate_ed25519()
    }

    #[tokio::test]
    async fn test_network_service_new() {
        let keypair = generate_keypair();
        let config_arg = NetworkConfig::default();
        let (incoming_tx_sender, _incoming_tx_receiver) = mpsc::channel(10);

        let service_result = NetworkService::new(config_arg, keypair, incoming_tx_sender).await;
        assert!(service_result.is_ok(), "Failed to create NetworkService: {:?}", service_result.err());
        if let Ok((_service, _command_sender)) = service_result {
            // Basic check that objects are created
        } else {
            panic!("NetworkService::new failed");
        }
    }

    #[test]
    fn test_network_message_serialization() {
        let keypair = generate_keypair();
        let sender_address = Address::from(keypair.public().to_peer_id().to_bytes());
        let recipient_address = Address([1u8; 32]);

        let transaction = Transaction {
            sender: sender_address,
            recipient: recipient_address,
            amount: 100,
            nonce: Nonce(1),
            signature: TypesSignature(keypair.sign(b"test_tx_data").expect("Signing failed")),
        };
        let network_msg_tx = NetworkMessage::NewTransaction(transaction.clone());

        let bincode_cfg = config::standard();
        let serialized_tx = bincode::encode_to_vec(&network_msg_tx, bincode_cfg).expect("Failed to serialize transaction message");
        let deserialized_tx: NetworkMessage = bincode::decode_from_slice(&serialized_tx, bincode_cfg).expect("Failed to deserialize transaction message");

        match deserialized_tx {
            NetworkMessage::NewTransaction(dtx) => assert_eq!(dtx, transaction),
            _ => panic!("Deserialized to wrong message type"),
        }
        
        let block_header = crate::block::BlockHeader {
            parent_hash: crate::types::Hash([0u8; 32]),
            block_number: BlockHeight(1),
            timestamp: Timestamp(0),
            tx_root: crate::types::Hash([1u8; 32]),
            validator: sender_address,
            signature: TypesSignature(keypair.sign(b"test_block_data").expect("Signing failed")),
        };
        let block = Block {
            header: block_header,
            transactions: vec![transaction.clone()],
        };
        let network_msg_block = NetworkMessage::NewBlock(block.clone());
        let serialized_block = bincode::encode_to_vec(&network_msg_block, bincode_cfg).expect("Failed to serialize block message");
        let deserialized_block: NetworkMessage = bincode::decode_from_slice(&serialized_block, bincode_cfg).expect("Failed to deserialize block message");

        match deserialized_block {
            NetworkMessage::NewBlock(dblock) => assert_eq!(dblock, block),
            _ => panic!("Deserialized to wrong message type for block"),
        }
    }

}
